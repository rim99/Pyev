## generated by RPythonic 0.4.8g	| host: 64bits
## http://code.google.com/p/rpythonic/
import os, sys, ctypes, inspect
__os = os
__sys = sys
__inspect = inspect
_CTYPES_CDLLS = []	# support loading functions from multiple libraries


PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert from is pass'.split()


IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)

_ISPYTHON2 = sys.version_info[0] == 2
if _ISPYTHON2: _NULLBYTE = '\0'
else: _NULLBYTE = bytes( chr(0), 'ascii' )

def _CHARP2STRING( charp, encoding='utf-8' ):
	b = bytes()
	i = 0
	while True:
		char = charp[ i ]
		if char == _NULLBYTE: break
		else:
			b += char
			i += 1
	return b.decode( encoding )

## try to load precompiled c-libraries from this directory, if the library is not there try to load from the system.
_clibs_dir = os.path.dirname(os.path.abspath(__file__))

def _load_ctypes_lib( name ):
	if __os.name == 'posix':
		if __sys.platform.startswith('linux'):
			if not name.endswith('.so'): name += '.so'
			if not name.startswith('lib'): name = 'lib' + name

			if IS32BIT: 	path = __os.path.join(_clibs_dir,'linux32')
			else: 		path = __os.path.join(_clibs_dir,'linux64')
			url = __os.path.join( path, name )
			if __os.path.isfile( url ): return ctypes.CDLL(url)
			elif __os.path.isfile( '/usr/local/lib/%s'%name ): return ctypes.CDLL('/usr/local/lib/%s'%name)
			elif __os.path.isfile( '/usr/local/lib64/%s'%name ) and not IS32BIT: return ctypes.CDLL('/usr/local/lib64/%s'%name)
			elif __os.path.isfile( '/usr/lib/%s'%name ): return ctypes.CDLL('/usr/lib/%s'%name)
			elif __os.path.isfile( './%s'%name ): return ctypes.CDLL('./%s'%name)
			
			elif __os.path.isfile( '/usr/lib/%s.0'%name ):	# Fedora style
				return ctypes.CDLL('/usr/lib/%s.0'%name )
			elif __os.path.isfile( '/usr/lib64/%s.0'%name ):	# Fedora style
				return ctypes.CDLL('/usr/lib64/%s.0'%name )

			else:	# fallback
				print('[ falling back to loading from current process ]')
				try: return ctypes.CDLL(name)
				except: return ctypes.CDLL('')

		elif sys.platform == 'darwin':
			name += '.dylib'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'osx32')
			else: 		path = os.path.join(_clibs_dir,'osx64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			else: return ctypes.CDLL(name) #fallback

	elif os.name == 'nt':
		name += '.dll'
		if IS32BIT: 	path = os.path.join(_clibs_dir,'win32')
		else: 		path = os.path.join(_clibs_dir,'win64')
		url = os.path.join( path, name )
		if os.path.isfile( url ): return ctypes.CDLL(url)
		else: return ctypes.CDLL(name) #fallback

RPYTHONIC_WRAPPER_FUNCTIONS = {}
RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES = []
RPYTHONIC_AUTOPREFIX_IGNORE = []

## ctypes does not clearly expose these types ##
PyCFuncPtrType = type(ctypes.CFUNCTYPE(ctypes.c_void_p))
PyCArrayType = type( ctypes.c_int * 2 )
PyCPointerType = type( ctypes.POINTER(ctypes.c_int) )
PyCStructType = type( ctypes.Structure )
CArgObject = type( ctypes.byref(ctypes.c_int()) )

class _rpythonic_meta_(object):
	'''
	Reserved Attributes:
		POINTER
		CSTRUCT
		CAST
	'''
	_rpythonic_ = True		# workaround for now, must have a way to know if object is a meta from another module, isinstance(o,_rpythonic_meta_) will fail in those cases. another workaround could be check sys.modules for other rpythonic modules and fetch _rpythonic_meta_ from there.
	def __init__(self, *args, **kw ):							# cheap trick, abuse **kw, and look for "pointer", "cast"
		if kw and 'pointer' not in kw: raise SyntaxError	# sorry, you can not init with keywords
		elif kw and 'pointer' in kw:
			if 'cast' in kw and kw['cast']:
				self.POINTER = ctypes.cast( kw['pointer'], ctypes.POINTER(self.CSTRUCT) )
			else: self.POINTER = kw['pointer']
		else: self.POINTER = ctypes.pointer( self.CSTRUCT(*args) )
		self.POINTER.pyobject = self	# .pyobject is local to this pointer "object"

	def __getattr__(self,name):
		if hasattr( self.POINTER.contents, name ):
			return getattr( self.POINTER.contents, name )

		else:	# when rpythonic failed to generate good bindings - these lookups should be cached
			for parent in self._rpythonic_parent_classes_:
				if hasattr( parent, name ):
					method = getattr( parent, name )	# should check if it really is an unbound method
					if method in parent._rpythonic_unbound_lookup_:
						func = parent._rpythonic_unbound_lookup_[ method ]
						n = func.name
						if len(func.argnames) > 1:
							argnames = func.argnames[ 1 : ]
							a = ',' + '=None,'.join( argnames ) + '=None'
							b = ','.join( argnames )
						else: a = b = ''
						lamb = eval( 'lambda self %s: %s( self.POINTER, %s )' %(a,n,b) )
						setattr( self.__class__, name, lamb )
						#return lamb	# this would return the unbound lambda, must call getattr again
						return getattr( self, name )
					else:
						# this can happen if self also inherits from the same parent class,
						# assume that by continuing this reaches that shared parent class,
						# and the lambda above is created as normal.
						continue
			## last resort, load from global name space ##
			G = globals()
			if name in G: return lambda *args: G[name](self.POINTER, *args)
			else:
				for prefix in self._autoprefix_:
					n = prefix + name
					if n in G: return lambda *args: G[n](self.POINTER, *args)
				print( 'possible auto-prefixes available', self._autoprefix_ )
				raise AttributeError

	def __call__(self, type=False):
		print('calling object is DEPRECATED - use ob.POINTER or ob.CSTRUCT')
		if type: return self.CSTRUCT
		else: return self.POINTER


def _rpythonic_generate_subclass_( name, struct, functions ):
	head = 'class %s( _rpythonic_meta_ ):' %name
	body = [ 
		'_rpythonic_parent_classes_ = []' ,
		'_rpythonic_unbound_lookup_ = {}' 
	]

	names = [ func.name for func in functions ]

	possibles = {}
	rank = []		# rank by longest name
	if len(names) > 3000: print('too many functions to use this hack')
	else:
		for n1 in names:
			prefix = ''
			for i,char in enumerate(n1):
				prefix += char
				if prefix not in possibles:
					possibles[ prefix ] = 0
					for n2 in names:
						if n2.startswith( prefix ):
							possibles[ prefix ] += 1

					if not rank or len(prefix) > len(rank[-1]) and possibles[prefix] > len(names)/4:
						rank.append( prefix )

	top = []
	while rank:
		best = rank.pop()
		if possibles[best] > len(functions)/2 and best not in names:
			if best.endswith('_set_') or best.endswith('_get_'): best = best[ : -4 ]
			elif best.endswith('Set') or best.endswith('Get'): best = best[ : -3 ]

			rem = []
			for other in rank:
				if best.startswith(other): rem.append( other )
			for r in rem: rank.remove( r )

			if best not in top: top.append( best )

		if len(top) > 3: break

	for n in names:		# find shortest prefixes #
		prefix = ''
		for i,char in enumerate(n):		# cammelCase
			if i==0: prefix += char; continue
			if char.isupper() and len(prefix) >= 2: break
			prefix += char
		if prefix and prefix != n and len(prefix) >= 2:
			hits = 0
			for other in names:
				if other.startswith( prefix ): hits += 1
			if hits >= 2 and prefix not in top:
				top.append( prefix )
				if len(top) >= 6: break

	## setup full names
	for func in functions:
		n = func.name
		if len(func.argnames) > 1:
			argnames = func.argnames[ 1 : ]
			a = ',' + '=None,'.join( argnames ) + '=None'
			b = ','.join( argnames )
		else: a = b = ''

		fhead = 'def %s( self %s ):' %(n,a)
		fbody = ['return %s(self.POINTER, %s)' %(func.name,b)]
		g = fhead + '\n\t\t' + '\n\t\t'.join( fbody )
		body.append( g )
		#body.append( '%s._rpythonic_function_ = %s' %(func.name, func.name) )

	## setup short names ##
	for n in names:
		for prefix in top:
			if n.startswith(prefix) and n[len(prefix):] not in names:
				alt = n[ len(prefix) : ]
				if alt and alt != n and alt not in PYTHON_RESERVED_KEYWORDS and not alt.isdigit() and not alt[0].isdigit():
					body.append( '%s = %s' %(alt,n) )
					names.append( alt )

	gen = head + '\n\t' + '\n\t'.join( body )
	try: exec( gen )
	except:
		print( gen )
		raise SyntaxError

	klass = locals()[name]
	klass.CSTRUCT = struct	# ctypes struct class

	klass._autoprefix_ = top
	for func in functions:
		unbound = getattr( klass, func.name )
		klass._rpythonic_unbound_lookup_[ unbound ] = func
		# klass.longname is klass.shortname = False
		# klass.longname == klass.shortname = True
	return klass

def _rpythonic_convert_structs_to_objects():
	G = globals()
	for klass in _OOAPI_:
		altname = name = klass.__name__
		prefix = ''
		for i,char in enumerate(name):
			if i==0: prefix += char; continue
			if char.isupper(): break
			prefix += char
		if prefix and prefix != name:
			hits = 0
			for other in _OOAPI_:
				if other is not klass:
					if other.__name__.startswith( prefix ): hits += 1
			if hits >= 2:
				altname = name[ len(prefix) : ]

		funcs = _OOAPI_[ klass ]
		newklass = _rpythonic_generate_subclass_( altname, klass, funcs )
		klass._rpythonic_wrapper_class_ = newklass
		G[ name ] = newklass	# replace struct with wrapper
		if altname not in G: G[ altname ] = newklass	# safely define with nicer name
		elif altname != name: # odd cases, maybe a function that returns the object, almost never happens.
			print('WARN - not replacing something with struct wrapper:', G[altname] )


def _rpythonic_setup_return_wrappers():
	R = _rpythonic_function_
	for klass in _OOAPI_:
		if klass in _OOAPI_RETURNS_OBJECT_:
			for f in _OOAPI_RETURNS_OBJECT_[klass]:
				f.object_oriented = True
				if not f.return_wrapper:	# just in case the ctypes footer had already defined it, do not overwrite
					f.return_wrapper = klass._rpythonic_wrapper_class_


###############################################################
##						OLD META FUNC						##
###############################################################
def _rpythonic_function_( name, result=ctypes.c_void_p, args=[]):
	mname = '_metafunc_%s' %name
	exec( 'class %s( _rpythonic_metafunc_ ): pass' %mname )
	k = locals()[mname]
	return k( name, result, args )
_OOAPI_ = {}
_OOAPI_RETURNS_OBJECT_ = {}
class _rpythonic_metafunc_(object):
	def __init__(self, name, result=ctypes.c_void_p, args=[]):
		self.name = name
		self.result = result
		self.argtypes = []		# can dynamically change CFUNCTYPE trick
		self.argnames = []
		self.argtypestypes = []
		for i,arg in enumerate(args):
			n,t = arg
			if n in PYTHON_RESERVED_KEYWORDS: n = 'C_'+n
			if n in self.argnames: n = '%s%s' %(n,i)
			self.argnames.append( n )
			self.argtypes.append( t )
			self.argtypestypes.append( type(t) )		# precomputed for speed

		self.argnames = tuple( self.argnames )				# should never change
		self.numargs = len( self.argtypes )
		self.callbacks = [None] * self.numargs
		self.return_wrapper = None
		self.object_oriented = False
		self.function = None
		for cdll in _CTYPES_CDLLS:	# functions could be multiple libraries
			if hasattr(cdll, self.name):
				func = self.function = getattr(cdll, self.name )
				RPYTHONIC_WRAPPER_FUNCTIONS[ name ] = self
				break
		if not self.function:
			RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES.append( name )

		if self.function: self.reset()

	def change_argument_type( self, name, t ):
		idx = self.argnames.index( name )
		self.argtypes[ idx ] = t
		self.argtypestypes[ idx ] = type(t)
		self.function.argtypes = self.argtypes

	def reset(self):
		if self.argnames:
			a = ',' + '=None,'.join( self.argnames ) + '=None'
			b = ','.join( self.argnames )
		else: a = b = ''

		callmeth = eval( 'lambda self %s: self._call_( %s )' %(a,b) )
		setattr( self.__class__, '__call__', callmeth )

		self.function.restype = self.result
		self.function.argtypes = self.argtypes

		if type( self.result ) is PyCPointerType and type(self.result._type_) is PyCStructType:
			klass = self.result._type_
			if klass not in _OOAPI_RETURNS_OBJECT_: _OOAPI_RETURNS_OBJECT_[klass] = []
			_OOAPI_RETURNS_OBJECT_[klass].append( self )

		self.defaults = []
		for i in range( self.numargs ):
			T = self.argtypes[ i ]
			if type(T) is PyCFuncPtrType:
				p = T()	# func pointers can not be None
				self.defaults.append( p )
				self.callbacks[ i ] = p					# save reference
			elif T in (ctypes.c_int, ctypes.c_uint, ctypes.c_long, ctypes.c_ulong):
				self.defaults.append( 0 )
			elif T in (ctypes.c_float, ctypes.c_double):
				self.defaults.append( .0 )
			else: self.defaults.append( None )	# None is allowed for all other types

			## generate OO API ##
			if i == 0 and type(T) is PyCPointerType and type(T._type_) is PyCStructType:
				klass = T._type_
				if klass not in _OOAPI_: _OOAPI_[ klass ] = []
				_OOAPI_[ klass ].append( self )

	def _call_( self, *args ):			# allow flexible calling types
		cargs = list( self.defaults )
		for i,arg in enumerate(args):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER
			elif hasattr( arg, '_rpythonic_' ): arg = arg.POINTER		# workaround - instance from another module

			t = type(arg)
			k = self.argtypes[ i ]
			kt = self.argtypestypes[ i ]
			if arg is None and cargs[i] is not None:	# use user defaults, very rare cases
				continue

			elif t is bool and k is ctypes.c_int:
				if arg: cargs[i] = 1	#ctypes.c_int(1)
				else: cargs[i] = 0	#ctypes.c_int(0)

			elif t in (list,tuple):				# convert lists and tuples into array
				if kt is PyCArrayType:
					cargs[ i ] = k(*arg)
				elif kt is PyCStructType:
					if k._array_wrapper_: cargs[ i ] = k(arg)	# allow easy array init
					else: cargs[ i ] = k(*arg)							# allow multiple args
				elif kt is PyCPointerType:
					cargs[ i ] = _convert_nested_list_to_pointer( k, arg )
				else: assert 0

			elif isinstance( arg, ctypes._Pointer ) and t is not k and kt is PyCPointerType:
				cargs[ i ] = ctypes.cast( arg, k )		# generic's that need to be cast

			elif kt is PyCStructType and isinstance( arg, ctypes._Pointer ):
				cargs[ i ] = arg.contents	# fixed may25

			elif kt is PyCPointerType and not isinstance( arg, (ctypes._Pointer,CArgObject) ):
				if t in (int,float,bool): ptr = k( k._type_(arg) )
				elif t is str:
					if not _ISPYTHON2: arg = arg.encode('utf-8')	# encode to ascii in python3
					ptr = ctypes.create_string_buffer(arg)				# correct and pypy compatible
				elif t in (PyCStructType, PyCArrayType):
					ptr = ctypes.cast( ctypes.pointer( arg ), k )
				else:
					ptr = arg	# TODO print warning?
				cargs[ i ] = ptr

			elif kt is PyCFuncPtrType:
				if t.__name__ == 'CFunctionType': cargs[ i ] = arg		# assume outside holds pointer
				else:													# this is not safe #
					cargs[ i ] = self.callbacks[ i ] = k( arg )				# assume arg is a callable
			else:
				cargs[ i ] = arg		# directly pass

		## if you define your own return_wrapper, it must take keyword "pointer"
		if self.return_wrapper: return self.return_wrapper( pointer=self.function( *cargs ) )
		else: return self.function( *cargs )



def _convert_nested_list_to_pointer( k, arg ):
	depth = 0; s = k
	while True:
		if type(s) is PyCPointerType:
			s = getattr( s, '_type_' )
			depth += 1
		else: break
	assert depth and depth <= 2
	if depth == 1:
		T = k._type_
		ptr = k( k._type_() )
		for i in range( len(arg) ):
			ptr[ i ] = T( *arg[i] )
	elif depth == 2:
		T = k._type_._type_
		_ptr = k._type_( k._type_._type_() )
		for i in range(len( arg )):
			for j in range( len(arg[i]) ):
				_ptr[ j ] = T( *arg[ i ][ j ] )
		ptr = k( _ptr )
	return ptr


def __freeze_rpythonic_struct( cls, fields ):
	if cls not in _OOAPI_: _OOAPI_[ cls ] = []	# wrap all structs
	try: setattr( cls, '_fields_', fields )
	except:
		print( 'WARN - bad order struct freeze', cls )
		#cls._fields_ = []

class _rpythonic_struct_( ctypes.Structure ):
	_array_wrapper_ = False
	_fields_ = []
	_methods_ = {}
	#def __call__(self): return self
	def __init__(self, *args, **kw ):
		cargs = []
		argtypes = []
		for a in self._fields_: argtypes.append( a[1] )
		if len(args) > len(argtypes): args = [args]	# allow both calling conventions
		for i,arg in enumerate( args ):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER

			t = type(arg)
			k = argtypes[ i ]
			if t in (list,tuple):
				if k.__class__.__name__	== 'PyCArrayType':
					cargs.append( k(*arg) )
				elif k.__class__.__name__ == 'PyCStructType':
					if k._array_wrapper_: cargs.append( k(arg) )	# allow easy array init
					else: cargs.append( k(*arg) )							# allow multiple args
			elif isinstance( arg, ctypes._Pointer ) and t is not k:
				cargs[ i ] = ctypes.cast( arg, k )	# generic's that need to be cast
			elif k.__class__.__name__ == 'PyCArrayType' and t in (float,int,bool):
				cargs.append( k(arg) )		# support init array from single value
			else:
				cargs.append( arg )		# directly pass

		ctypes.Structure.__init__(self, *cargs, **kw)


def _rpythonic_make_nice_global_enums_():
	G = globals()
	for name in RPYTHONIC_GLOBAL_ENUMS:
		if '_' in name and name.index('_') <= 4:
			altname = name[ name.index('_') + 1 : ]
			if altname not in G:
				G[altname] = RPYTHONIC_GLOBAL_ENUMS[ name ]

def _rpythonic_clean_up_missing_functions_():
	G = globals()
	for f in RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES:
		G.pop( f )
	print( "C functions loaded: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS) )
	print( "C functions failed: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES) )



###### NEW API #########
CTYPES_DLL = None

class _VOID_POINTER_CONTAINER_(object):
	def __init__(self, ptr, name=None):
		self._pointer_ = ptr
		self.name = name
NULL = _VOID_POINTER_CONTAINER_(None,'<null pointer>')


class meta:	# NEW API - allow run time switch from ctypes to rffi
	'''
	Methods:
		RPython will not allow object wrapper around a method (__call__ not allowed)
		keep C function names in list "__cfunctions__"
		rpythonic.enable_rffi( classA, classB )	
		can take advantage of methods in object-method-wrapper,
		generate rffi wrapper and set method on classA, etc.
		replaces object-method-wrapper with rffi-method

	Properties:
		CPython: obj.x=1
		RPython: obj.set_x(1)	
	'''
	METAS = []
	def __init__(self, constructors=[], methods={}, properties={}):
		#global CTYPES_DLL	# TODO update me to using _CTYPES_CDLLS
		#if not CTYPES_DLL:
		#	CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		self.constructors = constructors
		self.methods = methods
		self.properties = properties
		self.METAS.append( self )



	def __call__(self, cls ):
		print('@meta', cls )

		if not self.constructors:
			lamb = lambda s, _explicit_pointer_=None: setattr(s,'_pointer_',getattr(_explicit_pointer_,'_pointer_')) if hasattr(_explicit_pointer_,'_pointer_') else setattr(s,'_pointer_',_explicit_pointer_)
			lamb._debug = '(no constructor)'
			setattr( cls, '__init__', lamb )
		else:
			con = self._find_best_function( self.constructors )
			cfunc = self._build_cfunc( con )
			setattr( cls, '_%s'%con['name'], cfunc )
			g = self._gen_init( con )
			setattr( cls, '__init__', g )
		
		## set methods ##
		for name in self.methods:
			meth = self.methods[ name ]
			cfuncs = []
			for m in meth['functions']:
				cfunc = self._build_cfunc( m, method=True, static=meth['static'] )
				self._setup_return( cfunc, meth )
				setattr( cls, '_%s'%m['name'], cfunc )
				cfuncs.append( cfunc )

			f = self._find_best_function( meth['functions'] )
			g = self._gen_method( meth, f )
			g._cfuncs = cfuncs
			if meth['static']: g = classmethod( g )
			setattr( cls, name, g )

		for name in self.properties:
			print( 'property:', name )
			p = []
			for f in self.properties[name]:
				cfunc = self._build_cfunc( f )
				setattr( cls, '_%s'%f['name'], cfunc )
				g = self._gen_method( f, f )
				p.append( g )

			setattr( cls, name, property(*p) )

		return cls


	@staticmethod
	def _build_cfunc( info, method=False, static=False ):
		cfunc = getattr(CTYPES_DLL, info['name'])
		if method and not static: argtypes = [ ctypes.c_void_p ]
		else: argtypes = []
		for p in info['parameters']: argtypes.append( eval(p['ctypes_type']) )
		cfunc.argtypes = argtypes
		return cfunc

	@staticmethod
	def _setup_return( cfunc, info ):
		if not info['returns_fundamental']:
			cfunc.restype = ctypes.c_void_p
		elif info['returns_fundamental']:
			cfunc.restype = eval( info['returns_ctypes'] )
		else:
			cfunc.restype = ctypes.c_void_p

	@staticmethod
	def _gen_prepare_args( m ):
		a = []; b = []
		for i,p in enumerate(m['parameters']):
			if 'name' in p: n = p['name']
			else: n = '_unnamed_%s' %i
			if '<' in n: n = '_TODOfixme_%s' %i
			if n in PYTHON_RESERVED_KEYWORDS: n += str(i)
			if p['fundamental']:
				b.append( n )
				s = p['raw_type'].split()
				if 'default' in p:
					d = p['default']
					if p['raw_type'] in ('float', 'double'):
						if d.endswith('f'): d = d[:-1]
						d = d.replace(' ', '.')
						if 'e' in d: d = 0.0
						try: d = float(d)
						except: d = 0.0
					elif ('int' in s or 'size_t' in s) and not d.isdigit(): d = 0
					elif 'char' in s and '"' not in d: d = '""'
					elif d.lower() == 'false': d = False
					elif d.lower() == 'true': d = True
				elif 'char' in s: d = '""'
				elif 'float' in s or 'double' in s: d = 0.0
				elif 'size_t' in s or 'int' in s or 'long' in s or 'short' in s: d = 0
				elif p['raw_type'] == 'bool': d = False
				elif p['raw_type'] in ('void', '(template)'): d = 'NULL'
				else: print( p )
				a.append( n+'=%s' %d )

			else:
				b.append( '%s._pointer_'%n )
				a.append( n+'=NULL' )
		return a, b

	@staticmethod
	def _gen_init( m ):
		a, b = meta._gen_prepare_args( m )
		if a: e = 'lambda _py_self_, %s, _explicit_pointer_=None: ' %(','.join(a))
		else: e = 'lambda _py_self_, _explicit_pointer_=None: '
		e += 'setattr(_py_self_, "_pointer_", _py_self_._%s(%s))' %( m['name'], ','.join(b) )
		e += ' if not _explicit_pointer_ else '
		e += 'setattr(_py_self_, "_pointer_", _explicit_pointer_)'
		print( e )
		lamb = eval( e ); lamb._debug = e; lamb._introspect = m
		return lamb

	@staticmethod
	def _find_best_function( funcs ):
		best = funcs[0]
		score = -1
		if len(funcs) > 1:
			for f in funcs:
				hits = 0
				for p in f['parameters']:
					if p['fundamental']: hits += 1
				if hits and hits == len( f['parameters'] ):
					if hits > score:
						score = hits
						best = f
		return best

	@staticmethod
	def _gen_method( m, f ):
		a, b = meta._gen_prepare_args( f )
		if a: e = 'lambda _py_self_, %s: ' %(','.join(a))
		else: e = 'lambda _py_self_: '

		if 'static' in m and m['static']:	# static in c++ is like a classmethod
			c = '_py_self_._%s( %s )' %( f['name'], ','.join(b) )
		else:
			c = '_py_self_._%s( _py_self_._pointer_, %s )' %( f['name'], ','.join(b) )

		if not m['returns_fundamental']:
			if 'returns_unknown' in m or '<' in m['returns']: c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,m['returns'])
			else:
				something = m['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)

		e += c; lamb = eval( e )
		lamb._debug = e; lamb._introspect = f
		return lamb


	META_FUNCTIONS = []
	@classmethod
	def function( self, info ):
		print('@meta.function', info['name'] )
		#global CTYPES_DLL
		#if not CTYPES_DLL:
		#	CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		cfunc = self._build_cfunc( info, method=False, static=True )
		setattr( meta, '_%s'%info['name'], cfunc )
		self._setup_return( cfunc, info )
		a, b = meta._gen_prepare_args( info )
		e = 'lambda %s: ' %(','.join(a))
		c = 'meta._%s( %s )' %( info['name'], ','.join(b) )

		if not info['returns_fundamental']:
			if 'returns_unknown' in info or '<' in info['returns']:
				c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,info['returns'])
			else:
				something = info['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)
		e += c
		lamb = eval( e )
		lamb._debug = e
		lamb._introspect = info
		return lamb



def _rpythonic_strip_prefixes_( prefixes ):
	G = globals()
	names = list(G.keys())	# ensure list in py3
	for name in names:
		for prefix in prefixes:
			if name.startswith( prefix ):
				newname = name[ len(prefix) : ]
				if newname and newname not in G:
					G[ newname ] = G[ name ]


########################################################
##				Load Dynamic Libaries					##
def _rpythonic_load_dynamic_libraries(names):
	global _CTYPES_CDLLS
	for name in names:
		cdll = _load_ctypes_lib( name )
		if cdll:
			print('[[dynamic library loaded: %s]]' %name)
			_CTYPES_CDLLS.append( cdll )
#----------------------------------------------------------#
print( os.path.abspath( os.path.curdir ) )



_rpythonic_load_dynamic_libraries( ['libev'] )

## macro globals ##
EV_VERSION_MAJOR = 4
EV_VERSION_MINOR = 11
## enums ##
EV_UNDEF = 4294967295 
EV_NONE = 0 
EV_READ = 1 
EV_WRITE = 2 
EV__IOFDSET = 128 
EV_IO = 1 
EV_TIMER = 256 
EV_TIMEOUT = 256 
EV_PERIODIC = 512 
EV_SIGNAL = 1024 
EV_CHILD = 2048 
EV_STAT = 4096 
EV_IDLE = 8192 
EV_PREPARE = 16384 
EV_CHECK = 32768 
EV_EMBED = 65536 
EV_FORK = 131072 
EV_CLEANUP = 262144 
EV_ASYNC = 524288 
EV_CUSTOM = 16777216 
EV_ERROR = 2147483648 

SI_ASYNCNL = -60 
SI_TKILL = -6 
SI_SIGIO = -5 
SI_ASYNCIO = -4 
SI_MESGQ = -3 
SI_TIMER = -2 
SI_QUEUE = -1 
SI_USER = 0 
SI_KERNEL = 128 

ILL_ILLOPC = 1 
ILL_ILLOPN = 2 
ILL_ILLADR = 3 
ILL_ILLTRP = 4 
ILL_PRVOPC = 5 
ILL_PRVREG = 6 
ILL_COPROC = 7 
ILL_BADSTK = 8 

FPE_INTDIV = 1 
FPE_INTOVF = 2 
FPE_FLTDIV = 3 
FPE_FLTOVF = 4 
FPE_FLTUND = 5 
FPE_FLTRES = 6 
FPE_FLTINV = 7 
FPE_FLTSUB = 8 

SEGV_MAPERR = 1 
SEGV_ACCERR = 2 

BUS_ADRALN = 1 
BUS_ADRERR = 2 
BUS_OBJERR = 3 

TRAP_BRKPT = 1 
TRAP_TRACE = 2 

CLD_EXITED = 1 
CLD_KILLED = 2 
CLD_DUMPED = 3 
CLD_TRAPPED = 4 
CLD_STOPPED = 5 
CLD_CONTINUED = 6 

POLL_IN = 1 
POLL_OUT = 2 
POLL_MSG = 3 
POLL_ERR = 4 
POLL_PRI = 5 
POLL_HUP = 6 

SIGEV_SIGNAL = 0 
SIGEV_NONE = 1 
SIGEV_THREAD = 2 
SIGEV_THREAD_ID = 4 

SS_ONSTACK = 1 
SS_DISABLE = 2 

EVRUN_NOWAIT = 1 
EVRUN_ONCE = 2 

EVBREAK_CANCEL = 0 
EVBREAK_ONE = 1 
EVBREAK_ALL = 2 

EVFLAG_AUTO = 0 
EVFLAG_NOENV = 16777216 
EVFLAG_FORKCHECK = 33554432 
EVFLAG_NOINOTIFY = 1048576 
EVFLAG_NOSIGFD = 0 
EVFLAG_SIGNALFD = 2097152 
EVFLAG_NOSIGMASK = 4194304 

EVBACKEND_SELECT = 1 
EVBACKEND_POLL = 2 
EVBACKEND_EPOLL = 4 
EVBACKEND_KQUEUE = 8 
EVBACKEND_DEVPOLL = 16 
EVBACKEND_PORT = 32 
EVBACKEND_ALL = 63 
EVBACKEND_MASK = 65535 

## simple enums ##
RPYTHONIC_GLOBAL_ENUMS = { 
 "EV_UNDEF" : 4294967295,  "EV_NONE" : 0,  "EV_READ" : 1,  "EV_WRITE" : 2,  "EV__IOFDSET" : 128,  "EV_IO" : 1,  "EV_TIMER" : 256,  "EV_TIMEOUT" : 256,  "EV_PERIODIC" : 512,  "EV_SIGNAL" : 1024,  "EV_CHILD" : 2048,  "EV_STAT" : 4096,  "EV_IDLE" : 8192,  "EV_PREPARE" : 16384,  "EV_CHECK" : 32768,  "EV_EMBED" : 65536,  "EV_FORK" : 131072,  "EV_CLEANUP" : 262144,  "EV_ASYNC" : 524288,  "EV_CUSTOM" : 16777216,  "EV_ERROR" : 2147483648, 
 "SI_ASYNCNL" : -60,  "SI_TKILL" : -6,  "SI_SIGIO" : -5,  "SI_ASYNCIO" : -4,  "SI_MESGQ" : -3,  "SI_TIMER" : -2,  "SI_QUEUE" : -1,  "SI_USER" : 0,  "SI_KERNEL" : 128, 
 "ILL_ILLOPC" : 1,  "ILL_ILLOPN" : 2,  "ILL_ILLADR" : 3,  "ILL_ILLTRP" : 4,  "ILL_PRVOPC" : 5,  "ILL_PRVREG" : 6,  "ILL_COPROC" : 7,  "ILL_BADSTK" : 8, 
 "FPE_INTDIV" : 1,  "FPE_INTOVF" : 2,  "FPE_FLTDIV" : 3,  "FPE_FLTOVF" : 4,  "FPE_FLTUND" : 5,  "FPE_FLTRES" : 6,  "FPE_FLTINV" : 7,  "FPE_FLTSUB" : 8, 
 "SEGV_MAPERR" : 1,  "SEGV_ACCERR" : 2, 
 "BUS_ADRALN" : 1,  "BUS_ADRERR" : 2,  "BUS_OBJERR" : 3, 
 "TRAP_BRKPT" : 1,  "TRAP_TRACE" : 2, 
 "CLD_EXITED" : 1,  "CLD_KILLED" : 2,  "CLD_DUMPED" : 3,  "CLD_TRAPPED" : 4,  "CLD_STOPPED" : 5,  "CLD_CONTINUED" : 6, 
 "POLL_IN" : 1,  "POLL_OUT" : 2,  "POLL_MSG" : 3,  "POLL_ERR" : 4,  "POLL_PRI" : 5,  "POLL_HUP" : 6, 
 "SIGEV_SIGNAL" : 0,  "SIGEV_NONE" : 1,  "SIGEV_THREAD" : 2,  "SIGEV_THREAD_ID" : 4, 
 "SS_ONSTACK" : 1,  "SS_DISABLE" : 2, 
 "EVRUN_NOWAIT" : 1,  "EVRUN_ONCE" : 2, 
 "EVBREAK_CANCEL" : 0,  "EVBREAK_ONE" : 1,  "EVBREAK_ALL" : 2, 
 "EVFLAG_AUTO" : 0,  "EVFLAG_NOENV" : 16777216,  "EVFLAG_FORKCHECK" : 33554432,  "EVFLAG_NOINOTIFY" : 1048576,  "EVFLAG_NOSIGFD" : 0,  "EVFLAG_SIGNALFD" : 2097152,  "EVFLAG_NOSIGMASK" : 4194304, 
 "EVBACKEND_SELECT" : 1,  "EVBACKEND_POLL" : 2,  "EVBACKEND_EPOLL" : 4,  "EVBACKEND_KQUEUE" : 8,  "EVBACKEND_DEVPOLL" : 16,  "EVBACKEND_PORT" : 32,  "EVBACKEND_ALL" : 63,  "EVBACKEND_MASK" : 65535, 

}
class __sigset_t(_rpythonic_struct_): _array_wrapper_ = True
class __fsid_t(_rpythonic_struct_): _array_wrapper_ = True
class timespec(_rpythonic_struct_): pass
class sigval(ctypes.Union): pass
class siginfo(_rpythonic_struct_): pass
class _sifields(ctypes.Union): pass
class _kill(_rpythonic_struct_): pass
class _timer(_rpythonic_struct_): pass
class _rt(_rpythonic_struct_): pass
class _sigchld(_rpythonic_struct_): pass
class _sigfault(_rpythonic_struct_): pass
class _sigpoll(_rpythonic_struct_): pass
class sigevent(_rpythonic_struct_): pass
class _sigev_un(ctypes.Union): pass
class _sigev_thread(_rpythonic_struct_): pass
class sigaction(_rpythonic_struct_): pass
class __sigaction_handler(ctypes.Union): pass
class sigvec(_rpythonic_struct_): pass
class _fpreg(_rpythonic_struct_): _array_wrapper_ = True
class _fpxreg(_rpythonic_struct_): _array_wrapper_ = True
class _xmmreg(_rpythonic_struct_): _array_wrapper_ = True
class _fpstate(_rpythonic_struct_): _array_wrapper_ = True
class sigcontext(_rpythonic_struct_): _array_wrapper_ = True
class sigstack(_rpythonic_struct_): pass
class sigaltstack(_rpythonic_struct_): pass
class _libc_fpxreg(_rpythonic_struct_): _array_wrapper_ = True
class _libc_xmmreg(_rpythonic_struct_): _array_wrapper_ = True
class _libc_fpstate(_rpythonic_struct_): _array_wrapper_ = True
class mcontext_t(_rpythonic_struct_): _array_wrapper_ = True
class ucontext(_rpythonic_struct_): pass
class pthread_attr_t(ctypes.Union): pass
class __pthread_internal_list(_rpythonic_struct_): pass
class pthread_mutex_t(ctypes.Union): pass
class __pthread_mutex_s(_rpythonic_struct_): pass
class pthread_mutexattr_t(ctypes.Union): pass
class pthread_cond_t(ctypes.Union): pass
class pthread_condattr_t(ctypes.Union): pass
class pthread_rwlock_t(ctypes.Union): pass
class __data(_rpythonic_struct_): pass
class pthread_rwlockattr_t(ctypes.Union): pass
class pthread_barrier_t(ctypes.Union): pass
class pthread_barrierattr_t(ctypes.Union): pass
class stat(_rpythonic_struct_): _array_wrapper_ = True
class ev_loop(_rpythonic_struct_): pass
class ev_watcher(_rpythonic_struct_): pass
class ev_watcher_list(_rpythonic_struct_): pass
class ev_watcher_time(_rpythonic_struct_): pass
class ev_io(_rpythonic_struct_): pass
class ev_timer(_rpythonic_struct_): pass
class ev_periodic(_rpythonic_struct_): pass
class ev_signal(_rpythonic_struct_): pass
class ev_child(_rpythonic_struct_): pass
class ev_stat(_rpythonic_struct_): pass
class ev_idle(_rpythonic_struct_): pass
class ev_prepare(_rpythonic_struct_): pass
class ev_check(_rpythonic_struct_): pass
class ev_fork(_rpythonic_struct_): pass
class ev_cleanup(_rpythonic_struct_): pass
class ev_embed(_rpythonic_struct_): pass
class ev_async(_rpythonic_struct_): pass
class ev_any_watcher(ctypes.Union): pass
## union and structures ##
__freeze_rpythonic_struct( __sigset_t, [
	( "__val", ctypes.c_uint64 ),
])

__freeze_rpythonic_struct( __fsid_t, [
	( "__val", ( ctypes.c_int * 2 ) ),
])

__freeze_rpythonic_struct( timespec, [
	( "tv_sec", ctypes.c_int64 ),
	( "tv_nsec", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( sigval, [
	( "sival_int", ctypes.c_int ),
	( "sival_ptr", ctypes.POINTER(ctypes.c_void_p) ),
])

__freeze_rpythonic_struct( _kill, [
	( "si_pid", ctypes.c_int ),
	( "si_uid", ctypes.c_uint ),
])

__freeze_rpythonic_struct( _timer, [
	( "si_tid", ctypes.c_int ),
	( "si_overrun", ctypes.c_int ),
	( "si_sigval", sigval ),
])

__freeze_rpythonic_struct( _rt, [
	( "si_pid", ctypes.c_int ),
	( "si_uid", ctypes.c_uint ),
	( "si_sigval", sigval ),
])

__freeze_rpythonic_struct( _sigchld, [
	( "si_pid", ctypes.c_int ),
	( "si_uid", ctypes.c_uint ),
	( "si_status", ctypes.c_int ),
	( "si_utime", ctypes.c_int64 ),
	( "si_stime", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( _sigfault, [
	( "si_addr", ctypes.POINTER(ctypes.c_void_p) ),
])

__freeze_rpythonic_struct( _sigpoll, [
	( "si_band", ctypes.c_int64 ),
	( "si_fd", ctypes.c_int ),
])

__freeze_rpythonic_struct( _sifields, [
	( "_pad", ctypes.c_int ),
	( "_kill", _kill ),
	( "_timer", _timer ),
	( "_rt", _rt ),
	( "_sigchld", _sigchld ),
	( "_sigfault", _sigfault ),
	( "_sigpoll", _sigpoll ),
])

__freeze_rpythonic_struct( siginfo, [
	( "si_signo", ctypes.c_int ),
	( "si_errno", ctypes.c_int ),
	( "si_code", ctypes.c_int ),
	( "_sifields", _sifields ),
])

__freeze_rpythonic_struct( _sigev_thread, [
	( "_function", ctypes.c_void_p ),
	( "_attribute", ctypes.POINTER(ctypes.c_void_p) ),
])

__freeze_rpythonic_struct( _sigev_un, [
	( "_pad", ctypes.c_int ),
	( "_tid", ctypes.c_int ),
	( "_sigev_thread", _sigev_thread ),
])

__freeze_rpythonic_struct( sigevent, [
	( "sigev_value", sigval ),
	( "sigev_signo", ctypes.c_int ),
	( "sigev_notify", ctypes.c_int ),
	( "_sigev_un", _sigev_un ),
])

__freeze_rpythonic_struct( __sigaction_handler, [
	( "sa_handler", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,) ),
	( "sa_sigaction", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( sigaction, [
	( "__sigaction_handler", __sigaction_handler ),
	( "sa_mask", __sigset_t ),
	( "sa_flags", ctypes.c_int ),
	( "sa_restorer", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( sigvec, [
	( "sv_handler", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,) ),
	( "sv_mask", ctypes.c_int ),
	( "sv_flags", ctypes.c_int ),
])

__freeze_rpythonic_struct( _fpreg, [
	( "significand", ( ctypes.c_ushort * 4 ) ),
	( "exponent", ctypes.c_ushort ),
])

__freeze_rpythonic_struct( _fpxreg, [
	( "significand", ( ctypes.c_ushort * 4 ) ),
	( "exponent", ctypes.c_ushort ),
	( "padding", ( ctypes.c_ushort * 3 ) ),
])

__freeze_rpythonic_struct( _xmmreg, [
	( "element", ( ctypes.c_uint * 4 ) ),
])

__freeze_rpythonic_struct( _fpstate, [
	( "cwd", ctypes.c_uint16 ),
	( "swd", ctypes.c_uint16 ),
	( "ftw", ctypes.c_uint16 ),
	( "fop", ctypes.c_uint16 ),
	( "rip", ctypes.c_uint64 ),
	( "rdp", ctypes.c_uint64 ),
	( "mxcsr", ctypes.c_uint ),
	( "mxcr_mask", ctypes.c_uint ),
	( "_st", ( _fpxreg * 8 ) ),
	( "_xmm", ( _xmmreg * 16 ) ),
	( "padding", ( ctypes.c_uint * 24 ) ),
])

__freeze_rpythonic_struct( sigcontext, [
	( "r8", ctypes.c_ulong ),
	( "r9", ctypes.c_ulong ),
	( "r10", ctypes.c_ulong ),
	( "r11", ctypes.c_ulong ),
	( "r12", ctypes.c_ulong ),
	( "r13", ctypes.c_ulong ),
	( "r14", ctypes.c_ulong ),
	( "r15", ctypes.c_ulong ),
	( "rdi", ctypes.c_ulong ),
	( "rsi", ctypes.c_ulong ),
	( "rbp", ctypes.c_ulong ),
	( "rbx", ctypes.c_ulong ),
	( "rdx", ctypes.c_ulong ),
	( "rax", ctypes.c_ulong ),
	( "rcx", ctypes.c_ulong ),
	( "rsp", ctypes.c_ulong ),
	( "rip", ctypes.c_ulong ),
	( "eflags", ctypes.c_ulong ),
	( "cs", ctypes.c_ushort ),
	( "gs", ctypes.c_ushort ),
	( "fs", ctypes.c_ushort ),
	( "__pad0", ctypes.c_ushort ),
	( "err", ctypes.c_ulong ),
	( "trapno", ctypes.c_ulong ),
	( "oldmask", ctypes.c_ulong ),
	( "cr2", ctypes.c_ulong ),
	( "fpstate", ctypes.POINTER(_fpstate) ),
	( "__reserved1", ( ctypes.c_ulong * 8 ) ),
])

__freeze_rpythonic_struct( sigstack, [
	( "ss_sp", ctypes.POINTER(ctypes.c_void_p) ),
	( "ss_onstack", ctypes.c_int ),
])

__freeze_rpythonic_struct( sigaltstack, [
	( "ss_sp", ctypes.POINTER(ctypes.c_void_p) ),
	( "ss_flags", ctypes.c_int ),
	( "ss_size", ctypes.c_uint64 ),
])

__freeze_rpythonic_struct( _libc_fpxreg, [
	( "significand", ( ctypes.c_uint16 * 4 ) ),
	( "exponent", ctypes.c_uint16 ),
	( "padding", ( ctypes.c_uint16 * 3 ) ),
])

__freeze_rpythonic_struct( _libc_xmmreg, [
	( "element", ( ctypes.c_uint * 4 ) ),
])

__freeze_rpythonic_struct( _libc_fpstate, [
	( "cwd", ctypes.c_uint16 ),
	( "swd", ctypes.c_uint16 ),
	( "ftw", ctypes.c_uint16 ),
	( "fop", ctypes.c_uint16 ),
	( "rip", ctypes.c_uint64 ),
	( "rdp", ctypes.c_uint64 ),
	( "mxcsr", ctypes.c_uint ),
	( "mxcr_mask", ctypes.c_uint ),
	( "_st", ( _libc_fpxreg * 8 ) ),
	( "_xmm", ( _libc_xmmreg * 16 ) ),
	( "padding", ( ctypes.c_uint * 24 ) ),
])

__freeze_rpythonic_struct( mcontext_t, [
	( "gregs", ( ctypes.c_int64 * 23 ) ),
	( "fpregs", ctypes.POINTER(_libc_fpstate) ),
	( "__reserved1", ( ctypes.c_ulong * 8 ) ),
])

__freeze_rpythonic_struct( ucontext, [
	( "uc_flags", ctypes.c_uint64 ),
	( "uc_link", ctypes.POINTER(ucontext) ),
	( "uc_stack", sigaltstack ),
	( "uc_mcontext", mcontext_t ),
	( "uc_sigmask", __sigset_t ),
	( "__fpregs_mem", _libc_fpstate ),
])

__freeze_rpythonic_struct( pthread_attr_t, [
	( "__size", ( ctypes.c_char * 56 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( __pthread_internal_list, [
	( "__prev", ctypes.POINTER(__pthread_internal_list) ),
	( "__next", ctypes.POINTER(__pthread_internal_list) ),
])

__freeze_rpythonic_struct( __pthread_mutex_s, [
	( "__lock", ctypes.c_int ),
	( "__count", ctypes.c_uint ),
	( "__owner", ctypes.c_int ),
	( "__nusers", ctypes.c_uint ),
	( "__kind", ctypes.c_int ),
	( "__spins", ctypes.c_int ),
	( "__list", __pthread_internal_list ),
])

__freeze_rpythonic_struct( pthread_mutex_t, [
	( "__data", __pthread_mutex_s ),
	( "__size", ( ctypes.c_char * 40 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_mutexattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( __data, [
	( "__lock", ctypes.c_int ),
	( "__nr_readers", ctypes.c_uint ),
	( "__readers_wakeup", ctypes.c_uint ),
	( "__writer_wakeup", ctypes.c_uint ),
	( "__nr_readers_queued", ctypes.c_uint ),
	( "__nr_writers_queued", ctypes.c_uint ),
	( "__writer", ctypes.c_int ),
	( "__shared", ctypes.c_int ),
	( "__pad1", ctypes.c_uint64 ),
	( "__pad2", ctypes.c_uint64 ),
	( "__flags", ctypes.c_uint ),
])

__freeze_rpythonic_struct( pthread_cond_t, [
	( "__data", __data ),
	( "__size", ( ctypes.c_char * 48 ) ),
	( "__align", ctypes.c_longlong ),
])

__freeze_rpythonic_struct( pthread_condattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( pthread_rwlock_t, [
	( "__data", __data ),
	( "__size", ( ctypes.c_char * 56 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_rwlockattr_t, [
	( "__size", ( ctypes.c_char * 8 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_barrier_t, [
	( "__size", ( ctypes.c_char * 32 ) ),
	( "__align", ctypes.c_int64 ),
])

__freeze_rpythonic_struct( pthread_barrierattr_t, [
	( "__size", ( ctypes.c_char * 4 ) ),
	( "__align", ctypes.c_int ),
])

__freeze_rpythonic_struct( stat, [
	( "st_dev", ctypes.c_uint64 ),
	( "st_ino", ctypes.c_uint64 ),
	( "st_nlink", ctypes.c_uint64 ),
	( "st_mode", ctypes.c_uint ),
	( "st_uid", ctypes.c_uint ),
	( "st_gid", ctypes.c_uint ),
	( "__pad0", ctypes.c_int ),
	( "st_rdev", ctypes.c_uint64 ),
	( "st_size", ctypes.c_int64 ),
	( "st_blksize", ctypes.c_int64 ),
	( "st_blocks", ctypes.c_int64 ),
	( "st_atim", timespec ),
	( "st_mtim", timespec ),
	( "st_ctim", timespec ),
	( "__unused", ( ctypes.c_int64 * 3 ) ),
])

__freeze_rpythonic_struct( ev_loop, [
])

__freeze_rpythonic_struct( ev_watcher, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_watcher_list, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "next", ctypes.POINTER(ev_watcher_list) ),
])

__freeze_rpythonic_struct( ev_watcher_time, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "at", ctypes.c_double ),
])

__freeze_rpythonic_struct( ev_io, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "next", ctypes.POINTER(ev_watcher_list) ),
	( "fd", ctypes.c_int ),
	( "events", ctypes.c_int ),
])

__freeze_rpythonic_struct( ev_timer, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "at", ctypes.c_double ),
	( "repeat", ctypes.c_double ),
])

__freeze_rpythonic_struct( ev_periodic, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "at", ctypes.c_double ),
	( "offset", ctypes.c_double ),
	( "interval", ctypes.c_double ),
	( "reschedule_cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_signal, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "next", ctypes.POINTER(ev_watcher_list) ),
	( "signum", ctypes.c_int ),
])

__freeze_rpythonic_struct( ev_child, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "next", ctypes.POINTER(ev_watcher_list) ),
	( "flags", ctypes.c_int ),
	( "pid", ctypes.c_int ),
	( "rpid", ctypes.c_int ),
	( "rstatus", ctypes.c_int ),
])

__freeze_rpythonic_struct( ev_stat, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "next", ctypes.POINTER(ev_watcher_list) ),
	( "timer", ev_timer ),
	( "interval", ctypes.c_double ),
	( "path", ctypes.POINTER(ctypes.c_char) ),
	( "prev", stat ),
	( "attr", stat ),
	( "wd", ctypes.c_int ),
])

__freeze_rpythonic_struct( ev_idle, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_prepare, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_check, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_fork, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_cleanup, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
])

__freeze_rpythonic_struct( ev_embed, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "other", ctypes.POINTER(ev_loop) ),
	( "io", ev_io ),
	( "prepare", ev_prepare ),
	( "check", ev_check ),
	( "timer", ev_timer ),
	( "periodic", ev_periodic ),
	( "idle", ev_idle ),
	( "fork", ev_fork ),
	( "cleanup", ev_cleanup ),
])

__freeze_rpythonic_struct( ev_async, [
	( "active", ctypes.c_int ),
	( "pending", ctypes.c_int ),
	( "priority", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_void_p) ),
	( "cb", ctypes.c_void_p ),
	( "sent", ctypes.c_int ),
])

__freeze_rpythonic_struct( ev_any_watcher, [
	( "w", ev_watcher ),
	( "wl", ev_watcher_list ),
	( "io", ev_io ),
	( "timer", ev_timer ),
	( "periodic", ev_periodic ),
	( "signal", ev_signal ),
	( "child", ev_child ),
	( "stat", ev_stat ),
	( "idle", ev_idle ),
	( "prepare", ev_prepare ),
	( "check", ev_check ),
	( "fork", ev_fork ),
	( "cleanup", ev_cleanup ),
	( "embed", ev_embed ),
	( "async", ev_async ),
])

## wrapper functions ##
cb = _rpythonic_function_(		"cb", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_watcher)),
	("revents",		ctypes.c_int),] )

kill = _rpythonic_function_(		"kill", ctypes.c_int, [
	("__pid",		ctypes.c_int),
	("__sig",		ctypes.c_int),] )

killpg = _rpythonic_function_(		"killpg", ctypes.c_int, [
	("__pgrp",		ctypes.c_int),
	("__sig",		ctypes.c_int),] )

C_raise = _rpythonic_function_(		"C_raise", ctypes.c_int, [
	("__sig",		ctypes.c_int),] )

ssignal = _rpythonic_function_(		"ssignal", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,), [
	("__sig",		ctypes.c_int),
	("__handler",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,)),] )

gsignal = _rpythonic_function_(		"gsignal", ctypes.c_int, [
	("__sig",		ctypes.c_int),] )

psignal = _rpythonic_function_(		"psignal", ctypes.c_void_p, [
	("__sig",		ctypes.c_int),
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

psiginfo = _rpythonic_function_(		"psiginfo", ctypes.c_void_p, [
	("__pinfo",		ctypes.POINTER(siginfo)),
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

sigblock = _rpythonic_function_(		"sigblock", ctypes.c_int, [
	("__mask",		ctypes.c_int),] )

sigsetmask = _rpythonic_function_(		"sigsetmask", ctypes.c_int, [
	("__mask",		ctypes.c_int),] )

siggetmask = _rpythonic_function_(		"siggetmask", ctypes.c_int, [] )

sigemptyset = _rpythonic_function_(		"sigemptyset", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),] )

sigfillset = _rpythonic_function_(		"sigfillset", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),] )

sigaddset = _rpythonic_function_(		"sigaddset", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),
	("__signo",		ctypes.c_int),] )

sigdelset = _rpythonic_function_(		"sigdelset", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),
	("__signo",		ctypes.c_int),] )

sigismember = _rpythonic_function_(		"sigismember", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),
	("__signo",		ctypes.c_int),] )

sa_sigaction = _rpythonic_function_(		"sa_sigaction", ctypes.c_void_p, [
	("none",		ctypes.c_int),
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

sa_restorer = _rpythonic_function_(		"sa_restorer", ctypes.c_void_p, [] )

sigprocmask = _rpythonic_function_(		"sigprocmask", ctypes.c_int, [
	("__how",		ctypes.c_int),
	("__set",		ctypes.POINTER(__sigset_t)),
	("__oset",		ctypes.POINTER(__sigset_t)),] )

sigsuspend = _rpythonic_function_(		"sigsuspend", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),] )

_function = _rpythonic_function_(		"_function", ctypes.c_void_p, [
	("none",		ctypes.c_void_p),] )

signal = _rpythonic_function_(		"signal", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,), [
	("__sig",		ctypes.c_int),
	("__handler",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.c_int,)),] )

pthread_sigmask = _rpythonic_function_(		"pthread_sigmask", ctypes.c_int, [
	("__how",		ctypes.c_int),
	("__newmask",		ctypes.POINTER(__sigset_t)),
	("__oldmask",		ctypes.POINTER(__sigset_t)),] )

pthread_kill = _rpythonic_function_(		"pthread_kill", ctypes.c_int, [
	("__threadid",		ctypes.c_uint64),
	("__signo",		ctypes.c_int),] )

sigreturn = _rpythonic_function_(		"sigreturn", ctypes.c_int, [
	("__scp",		ctypes.POINTER(sigcontext)),] )

siginterrupt = _rpythonic_function_(		"siginterrupt", ctypes.c_int, [
	("__sig",		ctypes.c_int),
	("__interrupt",		ctypes.c_int),] )

futimens = _rpythonic_function_(		"futimens", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__times",		( timespec * 2 )),] )

lstat = _rpythonic_function_(		"lstat", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__buf",		ctypes.POINTER(stat)),] )

chmod = _rpythonic_function_(		"chmod", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),] )

lchmod = _rpythonic_function_(		"lchmod", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),] )

fchmod = _rpythonic_function_(		"fchmod", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__mode",		ctypes.c_uint),] )

fchmodat = _rpythonic_function_(		"fchmodat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),
	("__flag",		ctypes.c_int),] )

umask = _rpythonic_function_(		"umask", ctypes.c_uint, [
	("__mask",		ctypes.c_uint),] )

mkdir = _rpythonic_function_(		"mkdir", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),] )

mkdirat = _rpythonic_function_(		"mkdirat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),] )

mknod = _rpythonic_function_(		"mknod", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),
	("__dev",		ctypes.c_uint64),] )

sigpending = _rpythonic_function_(		"sigpending", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),] )

sigwait = _rpythonic_function_(		"sigwait", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),
	("__sig",		ctypes.POINTER(ctypes.c_int)),] )

sigwaitinfo = _rpythonic_function_(		"sigwaitinfo", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),
	("__info",		ctypes.POINTER(siginfo)),] )

sigtimedwait = _rpythonic_function_(		"sigtimedwait", ctypes.c_int, [
	("__set",		ctypes.POINTER(__sigset_t)),
	("__info",		ctypes.POINTER(siginfo)),
	("__timeout",		ctypes.POINTER(timespec)),] )

sigqueue = _rpythonic_function_(		"sigqueue", ctypes.c_int, [
	("__pid",		ctypes.c_int),
	("__sig",		ctypes.c_int),
	("__val",		sigval),] )

mknodat = _rpythonic_function_(		"mknodat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),
	("__dev",		ctypes.c_uint64),] )

mkfifo = _rpythonic_function_(		"mkfifo", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),] )

mkfifoat = _rpythonic_function_(		"mkfifoat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__mode",		ctypes.c_uint),] )

utimensat = _rpythonic_function_(		"utimensat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__times",		( timespec * 2 )),
	("__flags",		ctypes.c_int),] )

fstat = _rpythonic_function_(		"fstat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(stat)),] )

fstatat = _rpythonic_function_(		"fstatat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__buf",		ctypes.POINTER(stat)),
	("__flag",		ctypes.c_int),] )

ev_async_send = _rpythonic_function_(		"ev_async_send", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_async)),] )

ev_embed_start = _rpythonic_function_(		"ev_embed_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_embed)),] )

ev_embed_stop = _rpythonic_function_(		"ev_embed_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_embed)),] )

ev_embed_sweep = _rpythonic_function_(		"ev_embed_sweep", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_embed)),] )

ev_async_start = _rpythonic_function_(		"ev_async_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_async)),] )

ev_async_stop = _rpythonic_function_(		"ev_async_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_async)),] )

ev_fork_start = _rpythonic_function_(		"ev_fork_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_fork)),] )

ev_fork_stop = _rpythonic_function_(		"ev_fork_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_fork)),] )

ev_cleanup_start = _rpythonic_function_(		"ev_cleanup_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_cleanup)),] )

ev_cleanup_stop = _rpythonic_function_(		"ev_cleanup_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_cleanup)),] )

ev_idle_stop = _rpythonic_function_(		"ev_idle_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_idle)),] )

ev_prepare_start = _rpythonic_function_(		"ev_prepare_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_prepare)),] )

ev_prepare_stop = _rpythonic_function_(		"ev_prepare_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_prepare)),] )

ev_check_start = _rpythonic_function_(		"ev_check_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_check)),] )

ev_check_stop = _rpythonic_function_(		"ev_check_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_check)),] )

ev_stat_start = _rpythonic_function_(		"ev_stat_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_stat)),] )

ev_stat_stop = _rpythonic_function_(		"ev_stat_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_stat)),] )

ev_stat_stat = _rpythonic_function_(		"ev_stat_stat", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_stat)),] )

ev_idle_start = _rpythonic_function_(		"ev_idle_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_idle)),] )

ev_periodic_again = _rpythonic_function_(		"ev_periodic_again", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_periodic)),] )

ev_signal_start = _rpythonic_function_(		"ev_signal_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_signal)),] )

ev_signal_stop = _rpythonic_function_(		"ev_signal_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_signal)),] )

ev_child_start = _rpythonic_function_(		"ev_child_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_child)),] )

ev_child_stop = _rpythonic_function_(		"ev_child_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_child)),] )

ev_timer_again = _rpythonic_function_(		"ev_timer_again", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_timer)),] )

ev_timer_remaining = _rpythonic_function_(		"ev_timer_remaining", ctypes.c_double, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_timer)),] )

ev_periodic_start = _rpythonic_function_(		"ev_periodic_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_periodic)),] )

ev_periodic_stop = _rpythonic_function_(		"ev_periodic_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_periodic)),] )

ev_clear_pending = _rpythonic_function_(		"ev_clear_pending", ctypes.c_int, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ctypes.c_void_p)),] )

ev_io_start = _rpythonic_function_(		"ev_io_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_io)),] )

ev_io_stop = _rpythonic_function_(		"ev_io_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_io)),] )

ev_timer_start = _rpythonic_function_(		"ev_timer_start", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_timer)),] )

ev_timer_stop = _rpythonic_function_(		"ev_timer_stop", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ev_timer)),] )

ev_feed_fd_event = _rpythonic_function_(		"ev_feed_fd_event", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("fd",		ctypes.c_int),
	("revents",		ctypes.c_int),] )

ev_feed_signal = _rpythonic_function_(		"ev_feed_signal", ctypes.c_void_p, [
	("signum",		ctypes.c_int),] )

ev_feed_signal_event = _rpythonic_function_(		"ev_feed_signal_event", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("signum",		ctypes.c_int),] )

ev_invoke = _rpythonic_function_(		"ev_invoke", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ctypes.c_void_p)),
	("revents",		ctypes.c_int),] )

acquire = _rpythonic_function_(		"acquire", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_pending_count = _rpythonic_function_(		"ev_pending_count", ctypes.c_uint, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_invoke_pending = _rpythonic_function_(		"ev_invoke_pending", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_suspend = _rpythonic_function_(		"ev_suspend", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_resume = _rpythonic_function_(		"ev_resume", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_feed_event = _rpythonic_function_(		"ev_feed_event", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("w",		ctypes.POINTER(ctypes.c_void_p)),
	("revents",		ctypes.c_int),] )

ev_userdata = _rpythonic_function_(		"ev_userdata", ctypes.POINTER(ctypes.c_void_p), [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_set_invoke_pending_cb = _rpythonic_function_(		"ev_set_invoke_pending_cb", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("invoke_pending_cb",		ctypes.c_void_p),] )

invoke_pending_cb = _rpythonic_function_(		"invoke_pending_cb", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_set_loop_release_cb = _rpythonic_function_(		"ev_set_loop_release_cb", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("release",		ctypes.c_void_p),
	("acquire",		ctypes.c_void_p),] )

release = _rpythonic_function_(		"release", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_iteration = _rpythonic_function_(		"ev_iteration", ctypes.c_uint, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_depth = _rpythonic_function_(		"ev_depth", ctypes.c_uint, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_verify = _rpythonic_function_(		"ev_verify", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_set_io_collect_interval = _rpythonic_function_(		"ev_set_io_collect_interval", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("interval",		ctypes.c_double),] )

ev_set_timeout_collect_interval = _rpythonic_function_(		"ev_set_timeout_collect_interval", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("interval",		ctypes.c_double),] )

ev_set_userdata = _rpythonic_function_(		"ev_set_userdata", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("data",		ctypes.POINTER(ctypes.c_void_p)),] )

ev_ref = _rpythonic_function_(		"ev_ref", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_unref = _rpythonic_function_(		"ev_unref", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_once = _rpythonic_function_(		"ev_once", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("fd",		ctypes.c_int),
	("events",		ctypes.c_int),
	("timeout",		ctypes.c_double),
	("cb",		ctypes.c_void_p),
	("arg",		ctypes.POINTER(ctypes.c_void_p)),] )

ev_loop_destroy = _rpythonic_function_(		"ev_loop_destroy", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_loop_fork = _rpythonic_function_(		"ev_loop_fork", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_backend = _rpythonic_function_(		"ev_backend", ctypes.c_uint, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_now_update = _rpythonic_function_(		"ev_now_update", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_run = _rpythonic_function_(		"ev_run", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("flags",		ctypes.c_int),] )

ev_break = _rpythonic_function_(		"ev_break", ctypes.c_void_p, [
	("loop",		ctypes.POINTER(ev_loop)),
	("how",		ctypes.c_int),] )

ev_set_syserr_cb = _rpythonic_function_(		"ev_set_syserr_cb", ctypes.c_void_p, [
	("cb",		ctypes.c_void_p),] )

ev_default_loop = _rpythonic_function_(		"ev_default_loop", ctypes.POINTER(ev_loop), [
	("flags",		ctypes.c_uint),] )

ev_loop_new = _rpythonic_function_(		"ev_loop_new", ctypes.POINTER(ev_loop), [
	("flags",		ctypes.c_uint),] )

ev_now = _rpythonic_function_(		"ev_now", ctypes.c_double, [
	("loop",		ctypes.POINTER(ev_loop)),] )

ev_supported_backends = _rpythonic_function_(		"ev_supported_backends", ctypes.c_uint, [] )

ev_recommended_backends = _rpythonic_function_(		"ev_recommended_backends", ctypes.c_uint, [] )

ev_embeddable_backends = _rpythonic_function_(		"ev_embeddable_backends", ctypes.c_uint, [] )

ev_time = _rpythonic_function_(		"ev_time", ctypes.c_double, [] )

ev_sleep = _rpythonic_function_(		"ev_sleep", ctypes.c_void_p, [
	("delay",		ctypes.c_double),] )

ev_set_allocator = _rpythonic_function_(		"ev_set_allocator", ctypes.c_void_p, [
	("cb",		ctypes.POINTER(ctypes.c_void_p)),] )

ev_version_major = _rpythonic_function_(		"ev_version_major", ctypes.c_int, [] )

ev_version_minor = _rpythonic_function_(		"ev_version_minor", ctypes.c_int, [] )

reschedule_cb = _rpythonic_function_(		"reschedule_cb", ctypes.c_double, [
	("w",		ctypes.POINTER(ev_periodic)),
	("now",		ctypes.c_double),] )


_rpythonic_convert_structs_to_objects()
'''
Copyright 2011, Aaron Westendorf, All Rights Reserved.
https://github.com/awestendorf/eve/blob/master/LICENSE
Copyright (c) 2011 Aaron Westendorf
Updated June 2012 by Brett for libev-4.11

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

Define the constants used from libev/ev.h in ev.c. The case is preserved.
Spec'd to libev-4.04. Attempted to use documentation straight from libev for structs.
'''
ev_tstamp = ctypes.c_double

class ev_loop(ctypes.Structure):
  '''
  Assuming built wth EV_MULTIPLICITY.
  '''
  _fields_ = [
    ('ev_rt_now', ev_tstamp),
  ]

class _ev_watcher( ctypes.Structure ):
  _fields_ = [
    ('active', ctypes.c_int),
    ('pending', ctypes.c_int),
    ('priority', ctypes.c_int),
    ('data', ctypes.c_void_p),
    ('cb', ctypes.c_void_p),
  ]

class ev_watcher(ctypes.Structure):
  '''base class, nothing to see here unless you subclass'''
  _fields_ = [
    ('active', ctypes.c_int),
    ('pending', ctypes.c_int),
    ('priority', ctypes.c_int),  # TODO: handle "#if EV_MINPRI == EV_MAXPRI"
    ('data', ctypes.c_void_p),
    ('cb', ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(ev_loop), ctypes.POINTER(_ev_watcher), ctypes.c_int,))
  ]

# TODO: Determine if subclassing structs combines the _fields_ parameter

class ev_watcher_list(ctypes.Structure):
  '''base class, nothing to see here unless you subclass'''
  _fields_ = ev_watcher._fields_ + [
    ('next', ctypes.c_void_p), # TODO: make this real
  ]

class ev_watcher_time(ctypes.Structure):
  '''base class, nothing to see here unless you subclass'''
  _fields_ = ev_watcher._fields_ + [
    ('at', ev_tstamp),
  ]

class ev_io(ctypes.Structure):
  '''
  invoked when fd is either EV_READable or EV_WRITEable
  revent EV_READ, EV_WRITE
  '''
  _fields_ = ev_watcher_list._fields_ + [
    ('fd', ctypes.c_int), # ro
    ('events', ctypes.c_int), # ro
  ]

class ev_timer(ctypes.Structure):
  '''
  invoked after a specific time, repeatable (based on monotonic clock)
  revent EV_TIMEOUT
  '''
  _fields_ = ev_watcher_time._fields_ + [
    ('repeat', ev_tstamp), # rw
  ]

class ev_periodic(ctypes.Structure):
  '''
  invoked at some specific time, possibly repeating at regular intervals (based on UTC)
  revent EV_PERIODIC
  '''
  _fields_ = ev_watcher_time._fields_ + [
    ('offset', ev_tstamp), # rw
    ('interval', ev_tstamp), # rw
    ('callback', ctypes.CFUNCTYPE(ev_tstamp, ctypes.c_void_p, ev_tstamp))
  ]

class ev_signal(ctypes.Structure):
  '''
  invoked when the given signal has been received
  revent EV_SIGNAL
  '''
  _fields_ = ev_watcher_list._fields_ + [
    ('signum', ctypes.c_int), # ro
  ]

class ev_child(ctypes.Structure):
  '''
  invoked when sigchld is received and waitpid indicates the given pid
  revent EV_CHILD
  does not support priorities
  '''
  _fields_ = ev_watcher_list._fields_ + [
    ('flags', ctypes.c_int), # private
    ('pid', ctypes.c_int), # ro
    ('rpid', ctypes.c_int), # rw, holds the received pid
    ('rstatus', ctypes.c_int), # rw, holds the exit status, use the macros from sys/wait.h
  ]

class stat(ctypes.Structure):
  '''
  Defines sys/stat.h
  '''
  # TODO: Fill this in, figure something else out. Could just skip ev_stat
  # support.
  '''
  struct stat {
     dev_t     st_dev;     /* ID of device containing file */
     ino_t     st_ino;     /* inode number */
     mode_t    st_mode;    /* protection */
     nlink_t   st_nlink;   /* number of hard links */
     uid_t     st_uid;     /* user ID of owner */
     gid_t     st_gid;     /* group ID of owner */
     dev_t     st_rdev;    /* device ID (if special file) */
     off_t     st_size;    /* total size, in bytes */
     blksize_t st_blksize; /* blocksize for file system I/O */
     blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
     time_t    st_atime;   /* time of last access */
     time_t    st_mtime;   /* time of last modification */
     time_t    st_ctime;   /* time of last status change */
  };
  '''

# TODO: implement win32 support
'''
typedef struct _stati64 ev_statdata;
# else
typedef struct stat ev_statdata;
'''
ev_statdata = stat

class ev_stat(ctypes.Structure):
  '''
  invoked each time the stat data changes for a given path
  revent EV_STAT
  '''
  _fields_ = ev_watcher_list._fields_ + [
    ('timer', ev_timer), # private
    ('interval', ev_tstamp), # ro
    ('path', ctypes.c_char_p), # ro
    ('prev', ev_statdata), # ro
    ('attr', ev_statdata), # ro
    ('wd', ctypes.c_int), # wd for inotify, fd for kqueue 
  ]

class ev_idle(ctypes.Structure):
  '''
  invoked when the nothing else needs to be done, keeps the process from blocking
  revent EV_IDLE
  '''
  _fields_ = ev_watcher._fields_[:]

class ev_prepare(ctypes.Structure):
  '''
  invoked for each run of the mainloop, just before the blocking call
  you can still change events in any way you like
  revent EV_PREPARE
  '''
  _fields_ = ev_watcher._fields_[:]

class ev_check(ctypes.Structure):
  '''
  invoked for each run of the mainloop, just after the blocking call
  revent EV_CHECK
  '''
  _fields_ = ev_watcher._fields_[:]

#if EV_FORK_ENABLE
class ev_fork(ctypes.Structure):
  '''
  the callback gets invoked before check in the child process when a fork was detected
  revent EV_FORK
  '''
  _fields_ = ev_watcher._fields_[:]

class ev_cleanup(ctypes.Structure):
  '''
  is invoked just before the loop gets destroyed
  revent EV_CLEANUP
  '''
  _fields_ = ev_watcher._fields_[:]

class ev_embed(ctypes.Structure):
  '''
  used to embed an event loop inside another
  the callback gets invoked when the event loop has handled events, and can be 0
  '''
  _fields_ = ev_watcher._fields_ + [
    ('other', ctypes.c_void_p), # ro TODO: make this real
    ('io', ev_io), # private
    ('prepare', ev_prepare), # private
    ('check', ev_check), # unused
    ('timer', ev_timer), # unused
    ('periodic', ev_periodic), # unused
    ('idle', ev_idle), # unused
    ('fork', ev_fork), # private
    ('cleanup', ev_cleanup), # unused
  ]

#############################################

def ev_init(watcher, callback):
	watcher.active = 0
	watcher.pending = 0
	cfunctype = ev_watcher._fields_[-1][-1]
	if callback:
		watcher.cb = cfunctype( callback )
init = ev_init

def ev_io_init(watcher, cb, fd, events):
	ev_init(watcher, cb)
	ev_io_set( watcher, fd, events )
def ev_io_set( watcher, fd, events ):
	watcher.fd = fd
	watcher.events = events | EV__IOFDSET

def ev_timer_init(watcher, cb, after, repeat):
	ev_init(watcher, cb)
	ev_timer_set( watcher, after, repeat )
def ev_timer_set( watcher, after, repeat ):
	watcher.at = after
	watcher.repeat = repeat


def ev_periodic_init(watcher, cb, ofs, ival, rcb):
	ev_init( watcher, cb )
	ev_periodic_set( watcher, ofs, ival, rcb )
def ev_periodic_set( watcher, ofs, ival, rcb ):
	watcher.offset = ofs
	watcher.interval = ival
	watcher.reschedule_cb = rcb

def ev_signal_init(watcher, cb, signum):
	ev_init( watcher, cb )
	ev_signal_set( watcher, signum )
def ev_signal_set( watcher, signum ):
	watcher.signum = signum


def ev_child_init( watcher, cb, pid, trace ):
	ev_init( watcher, cb )
	ev_child_set( watcher, pid, trace )
def ev_child_set( watcher, pid, trace ):
	watcher.pid = pid
	watcher.flags = trace	# double bang? "(ev)->flags = !!(trace_);"

def ev_stat_init( watcher, callback, path, interval=0.0 ):
	ev_init( watcher, callback )
	ev_stat_set( watcher, path, interval )
def ev_stat_set(watcher, path, interval):
	watcher.path = path
	watcher.interval = interval
stat_init = ev_stat_init

def ev_idle_init( watcher, callback ): ev_init( watcher, callback )
def ev_prepare_init(watcher, callback): ev_init( watcher, callback )
def ev_check_init( watcher, callback ): ev_init( watcher, callback )
def ev_fork_init( watcher, callback ): ev_init( watcher, callback )
def ev_cleanup_init( watcher, callback ): ev_init( watcher, callback )
def ev_async_init( watcher, callback ): ev_init( watcher, callback )

def ev_is_pending( ev ): return 0 + ev.pending
def ev_is_active( ev ): return 0 + ev.active

def ev_priority( ev ): return ev.priority
def ev_set_priority( ev, pri ): ev.priority = pri

def ev_periodic_at(ev): return ev.at

EV_MINPRI = -2
EV_MAXPRI = 2

## fake macros - your libev may not be compiled this way,
## this is just to make gevent happy
EV_USE_FLOOR = 0    # off is slower/safer
EV_USE_CLOCK_SYSCALL = 1    # default
EV_USE_REALTIME = 0
EV_USE_MONOTONIC = 1
EV_USE_NANOSLEEP = 0
EV_USE_INOTIFY = 1
EV_USE_SIGNALFD = 1
EV_USE_EVENTFD = 1
EV_USE_4HEAP = 1    #default

_rpythonic_setup_return_wrappers()
_rpythonic_make_nice_global_enums_()
_rpythonic_clean_up_missing_functions_()
_rpythonic_strip_prefixes_(['ev_', 'EV_'])
